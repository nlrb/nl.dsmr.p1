"use strict";

var parser = require('../../node-dsmr-parser/index.js'),
	net = require('net'),
	event = require('events');


// Update a variable only if the value changes
function updateValue(state, what, newVal) {
	var curVal = state.values[what];
	var changed = curVal == null || (newVal instanceof Date ? newVal.getTime() !== curVal.getTime() : newVal != curVal);
	if (changed) {
		state.debug(what + ': was ' + curVal + ' now ' + newVal);
		state.values[what] = newVal;
		state.events.emit(what, newVal);
		return true;
	} else {
		return false;
	}
}
	
// Main constructor
function DSMR(settings, debug) {

	var self = this;
	this.id = settings.ip + ':' + settings.port;
	this.settings = settings;
	this.config = {};
	this.debug = function() { debug('[' + self.id + ']', arguments); };
	this.client;
	this.found = false;
	// Event handling
	this.events = new event.EventEmitter();
	// Received values
	this.incomingTelegram = '';
	this.values = {};
	// Power producers
	this.timeDelta = null;
	this.producerTimer = null;
	this.reconnectTimer;

	// Start communication
	this.openConnection(settings.ip, settings.port);
}

// Open the connection to this DSMR meter
DSMR.prototype.openConnection = function(ip, port) {
	var self = this;
	
	// Set up network communication
	this.client = new net.Socket();
	this.client.setTimeout(60000); // expect traffic once a minute
	// Register main response handler
	this.client.on('data', function(data) {
		//clearTimeout(waitTimer);
		self.processData(data);
	});
	// Error handler
	this.client.on('error', function(err) {
		self.debug(err);
		if (!self.found) {
			//clearTimeout(waitTimer);
			self.closeConnection();
		}
	});
	// Timeout handler
	this.client.on('timeout', function() {
		self.debug('Connecion timed out.');
		self.closeConnection();
	});
	// Handle closed connections, try to re-open it
	this.client.on('close', function() {
		self.debug('Connecion closed (found =', self.found + ')');
		self.events.emit('found', { found: false, err: 'Connection closed' });
		if (self.found && self.reconnectTimer === undefined) {
			// Connection dropped, try to re-connect every minute
			self.reconnectTimer = setInterval(function() {
				var ip = self.settings.ip;
				var port = self.settings.port;
				self.debug('Re-connecting to', ip + ':' + port);
				self.openConnection(ip, port);
			}, 60000);
		}
	});
	this.client.connect(port, ip, function() {
		self.debug('Connected to ' + self.id);
		// Kill the re-try timer
		clearInterval(self.reconnectTimer);
		self.reconnectTimer = undefined;
	});
}

// Close the connection to this DSMR meter
DSMR.prototype.closeConnection = function() {
    clearTimeout(this.producerTimer);
	this.producerTimer = null;
	this.found = false;
	this.events.removeAllListeners();
	this.client.destroy();
}

DSMR.prototype.processData = function(data) {
	if (data != null && data.length > 0) {
		data = data.toString();
		this.debug(data.replace('\n', ''));
		// Message: /XXXZ Ident CR LF CR LF Data ! CRC CR LF
		if (data[0] == '/') {
			this.incomingTelegram = data;
			// Request producer power on new message if no accurate timing yet
			if (this.settings.onTime == false || this.producerTimer == null) {
				this.events.emit('newMessage');
			}
		} else {
			this.incomingTelegram += data;
		}
		if (this.incomingTelegram[0] == '/' && this.incomingTelegram.slice(-7).match(/!.{4}\r\n/) != null) {
			var telegram;
			var ok = true;
			try {
				telegram = parser.parse(this.incomingTelegram);
			} catch(err) {
				this.debug('Telegram decode error:', err);
				ok = false;
			}
			if (ok) {
				for (var i in telegram.objects) {
					this.debug(i + ':', telegram.objects[i]);
				}
				// Process objects
				updateValue(this, 'actualWattDel', 1000 * telegram.objects['actual electricity power delivered']);
				updateValue(this, 'actualWattRec', 1000 * telegram.objects['actual electricity power received']);
				updateValue(this, 'actualWatt', this.values.actualWattDel - this.values.actualWattRec);
				
				updateValue(this, 'sumKwhDelT1', telegram.objects['electricity delivered tariff 1']);
				updateValue(this, 'sumKwhDelT2', telegram.objects['electricity delivered tariff 2']);
				updateValue(this, 'sumKwhRecT1', telegram.objects['electricity received tariff 1']);
				updateValue(this, 'sumKwhRecT2', telegram.objects['electricity received tariff 2']);
				updateValue(this, 'sumKwhT1', this.values.sumKwhDelT1 - this.values.sumKwhRecT1);
				updateValue(this, 'sumKwhT2', this.values.sumKwhDelT2 - this.values.sumKwhRecT2);
				updateValue(this, 'sumKwhDel', this.values.sumKwhDelT1 + this.values.sumKwhDelT1);
				updateValue(this, 'sumKwhRec', this.values.sumKwhRecT2 + this.values.sumKwhRecT2);
				updateValue(this, 'sumKwh', this.values.sumKwhT1 + this.values.sumKwhT2);
				// Gas
				var oldGas = this.values.sumGas;
				var oldGasTime = this.values.tsGas;
				updateValue(this, 'sumGas', telegram.objects['gas delivered']);
				if (updateValue(this, 'tsGas', telegram.objects['gas timestamp']) && oldGasTime != null) {
					var diffGas = (this.values.sumGas - oldGas) * 1000;
					var diffHr = this.values.tsGas.getUTCHours() - oldGasTime.getUTCHours();
					this.debug('Hours:liters', diffHr, ':', diffGas);
					if (diffHr > 0) {
						updateValue(this, 'flowGas', diffGas / diffHr);
					}
				};
				// For pairing
				if (!this.found) {
					this.found = true;
					this.config = { 
						id: telegram.objects['equipment identifier'],
						gid: telegram.objects['gas equipment identifier'],
						name: telegram.identifier,
						version: telegram.objects['dsmr version']
					};
					this.events.emit('found', { 
						found: true, 
						config: this.config
					});
				}
				if (this.settings.onTime) {
					// Measure producer power as close as possible to DSMR measurement
					this.timeDelta = 10000 - (new Date() - telegram.objects['timestamp']) + (this.settings.timeOffset || 0);
					this.timeDelta = Math.min(Math.max(0, this.timeDelta), 10000);
					this.debug('Time delta:', this.timeDelta);
					var self = this;
					this.producerTimer = setTimeout(function() {
						self.events.emit('newMessage');
					}, this.timeDelta);
				}
			} else if (!this.found) {
				this.events.emit('found', { found: false } );
			}
		}
	}
}

module.exports = DSMR;