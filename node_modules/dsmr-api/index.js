"use strict";

var DSMR = require('./lib/core.js');

var debugOn = false;
var locale = Homey.manager('i18n').getLanguage();
var meters = {};
var sensors = {};
var sensorQueue = {};

// Debug logging
function debug(text) {
	if (debugOn) {
		var now = new Date();
		if (typeof text == 'object') {
			var output = '';
			for (var property in text) {
			  output += property + ': ' + text[property]+'; ';
			};
			text = output;
		}
		var time = now.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1");
		var ms = ('00' + now.getMilliseconds()).slice(-3);
		Homey.log(time + '.' + ms + ' ' + text);
	}
}

var self = module.exports = {
	// debug function
	debug: debug,
	
	// Add a new meter or search for one
	addMeter: function(driver, device, settings) {
		// use ip:port as temporary id if serial number not known yet
		var id = device == null ? settings.ip + ':' + settings.port : device.id;
		if (meters[id] == null) {
			var dsmr = new DSMR(settings, debug);
			if (device != null) { // ID is correct
				meters[id] = dsmr;
				sensors[id] = [];
				self.addMeterActions(driver, device);
			} else {
				// Add event handlers
				dsmr.events.on('found', function(data) {
					if (data.found) {
						if (meters[data.id] == null) {
							data.device = {
								name: data.name,
								data: {	id: data.id },
								settings: settings,
								capabilities: [
									"measure_power", 
									"meter_power", 
									"meter_gas",
									{
										"id": "flow_gas",
										"type": "number",
										"title": {
											"en": "Gas Flow"
										},
										"units": {
											"en": "l/h"
										},
										"desc": {
											"en": "Amount of litres per hour"
										},
										"decimals": 2,
										"getable": true,
										"setable": true
									}
								]
							}
							meters[data.id] = dsmr;
							sensors[data.id] = [];
						} else {
							// Meter already present
							data.found = false;
						}
					}
					if (!data.found) {
						dsmr.closeConnection();
					}
					Homey.emit('found', data);
				});
			}
		} else {
			debug('Error: meter ' + id + ' already present.');
			Homey.emit('found', { found: false });
		}
	},
	
	// Add meter actions & child device actions
	addMeterActions: function(driver, device) {
		var id = device.id;
		meters[id].events.on('actualWatt', function(newVal) {
			driver.realtime(device, 'measure_power', newVal, function(err, success) {
				debug('Real-time meter watt update: ' + (err ? err : 'OK'));
			});
		});
		meters[id].events.on('actualKwh', function(newVal) {
			driver.realtime(device, 'meter_power', newVal, function(err, success) {
				debug('Real-time meter kwh update: ' + (err ? err : 'OK'));
			});
		});
		meters[id].events.on('actualGas', function(newVal) {
			driver.realtime(device, 'meter_gas', newVal, function(err, success) {
				debug('Real-time meter gas update: ' + (err ? err : 'OK'));
			});
		});
		// Add sensors in the queue (if any)
		if (sensorQueue[id] != null) {
			for (var i = 0; i < sensorQueue[id].length; i++) {
				var sensor = sensorQueue[id][i];
				self.addSensor(sensor.driver, sensor.device);
				sensor.driver.setAvailable(sensor.device);
			}
		}
	},
	
	// Remove a meter
	deleteMeter: function(id) {
		if (meters[id] != null) {
			meters[id].closeConnection();
			// mark all sensors as unavailable
			for (var i = 0; i < sensors[id].length; i++) {
				sensors[id][i].driver.setUnavailable(sensors[id][i].device, __('no_meter'));
			}
			delete meters[id];
			delete sensors[id];
		} else {
			debug('Error: meter ' + id + ' not present.');
		}
	},
	
	// Get a list of all registered meters
	getMeters: function() {
		var list = [];
		for (var item in meters) {
			var elem = meters[item].settings.config;
			list.push({ 
				id: item,
				type: elem.meterType,
				name: elem.meterName,
				serial: elem.meterSerial
			});
		}
		return list;
	},
	
	// Update meter configuration settings
	updateSettings: function(meter, changedItems, newSettings) {
		for (var i in changedItems) {
			var item = changedItems[i];
			var newVal = newSettings[item];
			Homey.log(item + ':' + newVal);
			// update setting
			meters[meter].devSettings[item] = newVal;
			// check if special action needed
			if (item == 'ip' || item == 'port') {
				// TODO: close connection & restart
			} else if (item == 'syncTime' && newVal) {
				meters[meter].syncTime();
			}
		}
	},
	
	// Add a sensor device
	addSensor: function(driver, device) {
		var meter = device.meter;
		if (meters[meter] != null) {
			debug("Adding device " + device.id);
			sensors[meter].push({ driver: driver, device: device });
			var did = device.id.split(':');
			meters[meter].events.on('zone.' + did[1], function(field, newVal) {
				if (field == 'battery') {
					driver.realtime(device, 'alarm_battery', newVal, function(err, success) {
						debug('Real-time battery update zone ' + did[1] + ': ' + (err ? err : 'OK'));
					});
				} else if (field == 'tamper') {
					driver.realtime(device, 'alarm_tamper', newVal, function(err, success) {
						debug('Real-time tamper update zone ' + did[1] + ': ' + (err ? err : 'OK'));
					});
				} else if (field == 'trip') {
					var event = (did[0] == 'magnet') ? 'alarm_contact' : (did[0] == 'motion' ? 'alarm_motion' : 'alarm_smoke');
					driver.realtime(device, event, newVal, function(err, success) {
						debug('Real-time tripped update zone ' + did[1] + ': ' + (err ? err : 'OK'));
					});
				}
			});
		} else {
			// meter not added yet...
			if (sensorQueue[meter] == null) {
				sensorQueue[meter] = [];
			}
			// or no meter at all?
			driver.setUnavailable(device, __('no_meter'));
			sensorQueue[meter].push({ driver: driver, device: device });
		}
	},
	
	// Delete a sensor device
	deleteSensor: function(device) {
		debug("Deleting device " + device.id);
		var meter = device.meter;
		for (var i = 0; i < sensors[meter].length; i++) {
			if (sensors[meter][i].device.id == device.id) {
				sensors[meter].splice(i, 1);
			}
		}
		// TODO: remove events
	},
	
	// Get sensors
	getSensors: function(meter, type) {
		var items = [];
		if (meters[meter] != null) {
			var list = meters[meter].settings.zones;
			if (meters[meter].readAllSettings) {
				for (var idx in list) {
					var elem = list[idx];
					if ((type == 'magnet' || type == 'wired') && elem.stype == 'Magnet') {
						var capabilities = ['alarm_contact', 'alarm_tamper'];
						if (type == 'magnet') {
							capabilities.splice(1, 0, 'alarm_battery');
						}
						items.push({
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'magnet:' + idx, meter: meter, zone: idx },
							capabilities: capabilities
						});
					} else if (type == 'motion' && elem.stype == 'Motion') {
						items.push({ 
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'motion:' + idx, meter: meter, zone: idx },
							capabilities: ['alarm_motion', 'alarm_battery', 'alarm_tamper']
						});
					} else if (type == 'smoke' && elem.stype == 'Smoke') {
						items.push({ 
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'smoke:' + idx, meter: meter, zone: idx },
							capabilities: ['alarm_smoke', 'alarm_battery', 'alarm_tamper']
						});
					}
				}
			}
		}
		return items;
	},
	
	// Get a meter value
	getValue: function(trigger, meter, callback) {
		if (meters[meter] != null) {
			var val = meters[meter].values[trigger];
			callback(null, val);
		} else {
			// Meter has been removed
			callback('Meter does not exist');
		}
	}
}