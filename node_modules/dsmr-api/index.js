"use strict";

const parser = require('../node-dsmr-parser/index.js'),
	net = require('net'),
	Events = require('events');

const map = {
	'actual electricity power delivered': { var: 'actualWattDel', mult: 1000 },
	'actual electricity power received': { var: 'actualWattRec', mult: 1000 },
	'electricity delivered tariff 1': { var: 'sumKwhDelT1' },
	'electricity delivered tariff 2': { var: 'sumKwhDelT2' },
	'electricity received tariff 1': { var: 'sumKwhRecT1' },
	'electricity received tariff 2': { var: 'sumKwhRecT2' },
	'instantaneous active power L1 delivered': { var: 'actualWattDelL1', mult: 1000 },
	'instantaneous active power L2 delivered': { var: 'actualWattDelL2', mult: 1000 },
	'instantaneous active power L3 delivered': { var: 'actualWattDelL3', mult: 1000 },
	'instantaneous active power L1 received': { var: 'actualWattRecL1', mult: 1000 },
	'instantaneous active power L2 received': { var: 'actualWattRecL2', mult: 1000 },
	'instantaneous active power L3 received': { var: 'actualWattRecL3', mult: 1000 },
	'instantaneous voltage L1': { var: 'actualVoltL1' },
	'instantaneous current L1': { var: 'actualCurrL1' },
	'instantaneous voltage L2': { var: 'actualVoltL2' },
	'instantaneous current L2': { var: 'actualCurrL2' },
	'instantaneous voltage L3': { var: 'actualVoltL3' },
	'instantaneous current L3': { var: 'actualCurrL3' }
}

/// Main constructor
class DSMR extends Events {

	constructor(ip, port, debug) {
		super();
		this.id = ip + ':' + port;
		this.settings = {
			ip: ip,
			port: port
		};
		this.config = {};
		this.debug = debug;
		this.client;
		this.found = false;
		// Received values
		this.incomingTelegram = '';
		this.values = new Map();
		// Power producers
		this.reconnectTimer;

		// Start communication
		this.openConnection(ip, port);
	}

	// Update a variable only if the value changes
	updateValue(what, newVal) {
		if (newVal !== undefined) {
			let curVal = this.values.get(what);
			let changed = curVal == null || (newVal instanceof Date ? newVal.getTime() !== curVal.getTime() : newVal != curVal);
			if (changed) {
				this.debug(what + ': was', curVal, 'now', newVal);
				this.values.set(what, newVal);
				this.emit(what, newVal);
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}

	// Open the connection to this DSMR meter
	openConnection(ip, port) {
		// Set up network communication
		this.client = new net.Socket();
		this.client.setTimeout(60000); // expect traffic once a minute
		// Register main response handler
		this.client.on('data', (data) => {
			//clearTimeout(waitTimer);
			this.processData(data);
		});
		// Error handler
		this.client.on('error', (err) => {
			this.debug(err);
			if (!this.found) {
				//clearTimeout(waitTimer);
				this.closeConnection();
			}
		});
		// Timeout handler
		this.client.on('timeout', () => {
			this.debug('Connecion timed out.');
			this.closeConnection();
		});
		// Handle closed connections, try to re-open it
		this.client.on('close', () => {
			this.debug('Connecion closed (found =', this.found + ')');
			this.emit('found', { found: false, err: 'Connection closed' });
			if (this.found && this.reconnectTimer === undefined) {
				// Connection dropped, try to re-connect every minute
				this.reconnectTimer = setInterval(() => {
					let ip = this.settings.ip;
					let port = this.settings.port;
					this.debug('Re-connecting to', ip + ':' + port);
					this.openConnection(ip, port);
				}, 60000);
			}
		});
		this.client.connect(port, ip, () => {
			this.debug('Connected to', this.id);
			// Kill the re-try timer
			clearInterval(this.reconnectTimer);
			this.reconnectTimer = undefined;
		});
	}

	// Close the connection to this DSMR meter
	closeConnection() {
		this.found = false;
		this.removeAllListeners();
		this.client.destroy();
	}

	// Process incoming DSMR data
	processData(data) {
		if (data != null && data.length > 0) {
			data = data.toString();
			this.debug('>>>' + data.replace(/\r\n/g, '_') + '<<<');
			// Message (v4): /XXXZ Ident CR LF CR LF Data ! CRC CR LF
			if (data[0] == '/') {
				this.incomingTelegram = data;
			} else {
				this.incomingTelegram += data;
			}
			if (this.incomingTelegram[0] == '/'
			    && this.incomingTelegram.lastIndexOf('!') >= 0
			    && this.incomingTelegram.slice(-2) === '\r\n')
			{
				let telegram;
				let ok = true;
				try {
					telegram = parser.parse(this.incomingTelegram);
				} catch(err) {
					this.debug('Telegram decode error:', err);
					ok = false;
				}
				if (ok) {
					/*
					for (let i in telegram.objects) {
						this.debug(i + ':', telegram.objects[i]);
					}
					*/
					// Process objects
					for (let i in map) {
						let item = map[i];
						let value = telegram.objects[i];
						if (value !== undefined) {
							if (item.mult) {
								value *= item.mult;
							}
							this.updateValue(item.var, value);
						}
					}

					// Calculated values that always exist
					this.updateValue('actualWatt', this.values.get('actualWattDel') - this.values.get('actualWattRec'));
					this.updateValue('sumKwhT1', this.values.get('sumKwhDelT1') - this.values.get('sumKwhRecT1'));
					this.updateValue('sumKwhT2', this.values.get('sumKwhDelT2') - this.values.get('sumKwhRecT2'));
					this.updateValue('sumKwhDel', this.values.get('sumKwhDelT1') + this.values.get('sumKwhDelT1'));
					this.updateValue('sumKwhRec', this.values.get('sumKwhRecT2') + this.values.get('sumKwhRecT2'));
					this.updateValue('sumKwh', this.values.get('sumKwhT1') + this.values.get('sumKwhT2'));

					// Calculated
					if (this.values.get('actualWattDelL1') !== undefined) {
						this.updateValue('actualWattL1', this.values.get('actualWattDelL1') + this.values.get('actualWattRecL1'));
					}
					if (this.values.get('actualWattDelL2') !== undefined) {
						this.updateValue('actualWattL2', this.values.get('actualWattDelL2') + this.values.get('actualWattRecL2'));
					}
					if (this.values.get('actualWattDelL3') !== undefined) {
						this.updateValue('actualWattL3', this.values.get('actualWattDelL3') + this.values.get('actualWattRecL3'));
					}

					// Gas
					let oldGas = this.values.get('sumGas');
					let oldGasTime = this.values.get('tsGas');
					this.updateValue('sumGas', telegram.objects['gas delivered']);
					if (this.updateValue('tsGas', telegram.objects['gas timestamp']) && oldGasTime != null) {
						let diffGas = (this.values.get('sumGas') - oldGas) * 1000;
						let diffHr = this.values.get('tsGas').getUTCHours() - oldGasTime.getUTCHours();
						this.debug('Hours:liters', diffHr, ':', diffGas);
						if (diffHr > 0) {
							this.updateValue('flowGas', diffGas / diffHr);
						}
					};
					// For pairing
					if (!this.found) {
						this.found = true;
						this.config = {
							id: telegram.objects['equipment identifier'],
							gid: telegram.objects['gas equipment identifier'],
							name: telegram.identifier.replace('\\', ''),
							version: telegram.objects['dsmr version']
						};
						this.emit('found', {
							found: true,
							config: this.config
						});
					}
				} else if (!this.found) {
					this.emit('found', { found: false } );
				}
			}
		}
	}

}

module.exports = DSMR;
