"use strict";

var DSMR = require('./lib/core.js');

var debugOn = false;
var locale = Homey.manager('i18n').getLanguage();
var meters = {};
var sensors = {};
var sensorQueue = {};
var producers = {};
var produced = { cnt: 0, sum: 0 };

var sensor_list = [
	{ var: 'actualWattDel', unit: 'W', en: 'Using', nl: 'Verbruik' },
	{ var: 'actualWattRec', unit: 'W', en: 'Delivering', nl: 'Teruglevering' },
	{ var: 'actualWatt', unit: 'W', en: 'Actual sum', nl: 'Actuele som' },
	{ var: 'sumKwhDelT1', unit: 'kWh', en: 'Tariff 1 used', nl: 'Normaal tarief verbruikt' },
	{ var: 'sumKwhRecT1', unit: 'kWh', en: 'Tariff 1 delivered', nl: 'Normaal tarief teruggeleverd' },
	{ var: 'sumKwhT1', unit: 'kWh', en: 'Tariff 1 sum', nl: 'Normaal tarief som' },
	{ var: 'sumKwhDelT2', unit: 'kWh', en: 'Tariff 2 used', nl: 'Daltarief verbruikt' },
	{ var: 'sumKwhRecT2', unit: 'kWh', en: 'Tariff 2 delivered', nl: 'Daltarief teruggeleverd' },
	{ var: 'sumKwhT2', unit: 'kWh', en: 'Tariff 2 sum', nl: 'Daltarief som' },
	{ var: 'sumKwhDel', unit: 'kWh', en: 'Total used', nl: 'Total gebruikt' },
	{ var: 'sumKwhRec', unit: 'kWh', en: 'Total delivered', nl: 'Totaal teruggeleverd' },
	{ var: 'sumKwh', unit: 'kWh', en: 'Total sum', nl: 'Totale som' }
]


// Debug logging
function debug() {
	if (debugOn) {
		var now = new Date();
		var isCircular = (d) => { try {JSON.stringify(d) } catch (e) {return true} return false };
		var itemdebug = (x) => { return (typeof x === 'object' && !isCircular(x) ? JSON.stringify(x) : x) + ' ' };
		var time = now.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1");
		var ms = ('00' + now.getMilliseconds()).slice(-3);
		var text = '';
		for (var i = 0; i < arguments.length; i++) {
			var x = arguments[i];
			if (Object.prototype.toString.call(arguments[i]) === '[object Arguments]') {
				for (var j = 0; j < x.length; j++) {
					text += itemdebug(x[j]);
				}
			} else {
				text += itemdebug(x);
			}
		}
		Homey.log(time + '.' + ms, text.slice(0, -1));
	}
}

var self = module.exports = {
	// debug function
	debug: debug,
	
	// Allow turning debug info on/off
	setDebug: function(on_off) {
		debugOn = on_off;
	},
	
	// Add a new meter or search for one
	addMeter: function(driver, device, settings) {
		// use ip:port as temporary id if serial number not known yet
		var id = device == null ? settings.ip + ':' + settings.port : device.id;
		if (meters[id] == null) {
			var dsmr = new DSMR(settings, debug);
			if (device != null) { // ID is correct
				meters[id] = dsmr;
				sensors[id] = [];
				self.addMeterActions(driver, device);
			} else {
				// Add event handlers
				dsmr.events.on('found', function(data) {
					if (data.found) {
						if (meters[data.id] == null) {
							data.device = {
								name: data.name,
								data: {	id: data.id },
								settings: settings
							}
							meters[data.id] = dsmr;
							sensors[data.id] = [];
						} else {
							// Meter already present
							data.found = false;
						}
					}
					if (!data.found) {
						dsmr.closeConnection();
					}
					Homey.emit('found', data);
				});
			}
		} else {
			debug('Error: meter ' + id + ' already present.');
			Homey.emit('found', { found: false });
		}
	},
	
	// Add meter actions & child device actions
	addMeterActions: function(driver, device) {
		var id = device.id;
		meters[id].events.on('newMessage', function() {
			if (meters[id].settings.compensate) {
				debug('Requesting producer sum');
				meters[id].values.realSum = { dsmr: { ready: false, value: 0 }, producers: { ready: false, value: 0 } };
				self.getProducerSum(id, function(produced) {
					debug('Sum received: ' + produced);
					meters[id].values.realSum.producers = { ready: true, value: produced };
					meters[id].events.emit('actualWatt', meters[id].values.realSum.producers);
				});
			} else {
				meters[id].values.realSum = { dsmr: { ready: false, value: 0 }, producers: { ready: true, value: 0 } };
			}
		});
		meters[id].events.on('actualWatt', function(newVal) {
			if (typeof newVal != 'object') {
				meters[id].values.realSum.dsmr = { ready: true, value: newVal };
			}
			if (meters[id].values.realSum.dsmr.ready && meters[id].values.realSum.producers.ready) {
				meters[id].values.measuredWatt = meters[id].values.realSum.dsmr.value + meters[id].values.realSum.producers.value;
				driver.realtime(device, 'measure_power', meters[id].values.measuredWatt, function(err, success) {
					debug('Real-time meter watt update: ' + (err ? err : 'OK'));
				});
			}
		});
		meters[id].events.on('sumKwh', function(newVal) {
			driver.realtime(device, 'meter_power', newVal, function(err, success) {
				debug('Real-time meter kwh update: ' + (err ? err : 'OK'));
			});
		});
		meters[id].events.on('sumGas', function(newVal) {
			driver.realtime(device, 'meter_gas', newVal, function(err, success) {
				debug('Real-time meter gas update: ' + (err ? err : 'OK'));
			});
		});
		// Add sensors in the queue (if any)
		if (sensorQueue[id] != null) {
			for (var i = 0; i < sensorQueue[id].length; i++) {
				var sensor = sensorQueue[id][i];
				self.addSensor(sensor.driver, sensor.device);
				sensor.driver.setAvailable(sensor.device);
			}
		}
	},
	
	// Remove a meter
	deleteMeter: function(id) {
		if (meters[id] != null) {
			meters[id].closeConnection();
			// mark all sensors as unavailable
			for (var i = 0; i < sensors[id].length; i++) {
				sensors[id][i].driver.setUnavailable(sensors[id][i].device, __('no_meter'));
			}
			delete meters[id];
			delete sensors[id];
		} else {
			debug('Error: meter ' + id + ' not present.');
		}
	},
	
	// Get a list of all registered meters
	getMeters: function() {
		var list = [];
		for (var item in meters) {
			var elem = meters[item].settings.config;
			list.push({ 
				id: item,
				type: elem.meterType,
				name: elem.meterName,
				serial: elem.meterSerial
			});
		}
		return list;
	},
	
	// Update meter configuration settings
	updateSettings: function(meter, changedItems, newSettings) {
		for (var i in changedItems) {
			var item = changedItems[i];
			var newVal = newSettings[item];
			debug(item + ':' + newVal);
			// update setting
			meters[meter].settings[item] = newVal;
			// check if special action needed
			if (item == 'ip' || item == 'port') {
				// TODO: close connection & restart
			}
		}
	},
	
	// Get a meter value
	getValue: function(trigger, meter, callback) {
		if (meters[meter] != null) {
			var val = meters[meter].values[trigger];
			callback(null, val);
		} else {
			// Meter has been removed
			callback('Meter does not exist');
		}
	},
	
	// Register a power producing device
	registerProducer: function(prod, callback) {
		// TODO: make persistent and load on start
		debug('Callback registered: ' + callback);
		if (prod != null && callback != null && producers[prod] == null) {
			if (typeof callback == 'string') {
				producers[prod] = { pollValue: callback };
			}
		}
	},
	
	// Calculate the sum of all producers
	getProducerSum: function(id, callback) {
		debug('Number of registered producers: ' + Object.keys(producers).length);
		if (Object.keys(producers).length > 0) {
			produced.data = {
				cnt: 0,
				sum: 0,
				callback: callback
			}
			for (var prod in producers) {
				var get = producers[prod].pollValue;
				debug('Getting producer ' + prod + ' value (' + get + ')...');
				Homey.manager('api').post(get, { id: prod }, function(err, result) {
					debug('Read request sent: ' + err + ' : ' + result);
				});
			}
		} else {
			callback(0);
		}
	},
	
	// Receive a value from a producer and add to the total
	receiveProducerValue: function(prod, value, err) {
		debug('Result of producer ' + prod + ' = ' + value);
		produced.data.cnt++;
		if (!err) {
			produced.data.sum += value;
		}
		if (produced.data.callback != null && produced.data.cnt == Object.keys(producers).length) {
			debug('Final sum of producers = ' + produced.data.sum);
			produced.data.callback(produced.data.sum); // communicate final sum
		}
	},
	
	// Get a list of all registered meters
	getMeters: function() {
		var list = [];
		for (var item in meters) {
			var elem = meters[item].config;
			list.push({ 
				id: item,
				name: elem.name,
				serial: elem.serial
			});
		}
		return list;
	},
	
	// Add a sensor device
	addSensor: function(driver, device) {
		var meter = device.meter;
		if (meters[meter] != null) {
			debug("Adding device " + device.id);
			var variable = device.variable;
			var action = (newVal) => {
				var capability = device.unit == 'kWh' ? 'meter_power' : 'measure_power';
				driver.realtime(device, capability, newVal, function(err, success) {
					debug('Real-time power update variable ' + variable + ': ' + (err ? err : 'OK'));
				});
			}
			sensors[meter].push({ driver: driver, device: device, action: action });
			meters[meter].events.on(variable, action);
		} else {
			// Meter not added yet...
			if (sensorQueue[meter] == null) {
				sensorQueue[meter] = [];
			}
			// or no meter at all?
			driver.setUnavailable(device, __('no_meter'));
			sensorQueue[meter].push({ driver: driver, device: device });
		}
	},
	
	// Delete a sensor device
	deleteSensor: function(device) {
		debug("Deleting device " + device.id);
		var meter = device.meter;
		for (var i = 0; i < sensors[meter].length; i++) {
			if (sensors[meter][i].device.id == device.id) {
				// Remove event listener
				meters[meter].events.removeListener(device.variable, sensors[meter][i].action);
				sensors[meter].splice(i, 1);
			}
		}
	},
	
	// Get sensors
	getSensors: function(meter, type) {
		var items = [];
		if (meters[meter] != null) {
			for (var i = 0; i < sensor_list.length; i++) {
				var elem = sensor_list[i];
				items[i] = {
					name: elem[locale] + ' (' + elem.unit + ')',
					data: {	id: 'dsmr:' + elem.var, variable: elem.var, unit: elem.unit, meter: meter },
					capabilities: [ (elem.unit == 'kWh' ? 'meter_power' : 'measure_power') ]
				};
			}
		}
		return items;
	}
}